---
title: "Matches API"
description: "Complete match booking system with participants and winner tracking"
---

## Overview

The Matches API provides comprehensive match booking functionality, including match creation, participant management, winner setting, and match retrieval for shows.

## Match Operations

### Create Match

<CodeGroup>

```rust Frontend (Leptos)
use crate::types::{create_match, MatchData};

let match_data = MatchData {
    show_id: 1,
    match_name: Some("Main Event Championship Match".to_string()),
    match_type: "Singles".to_string(),
    match_stipulation: Some("Title Match".to_string()),
    scheduled_date: None,
    match_order: Some(5),
    is_title_match: true,
    title_id: Some(1),
};

let match_obj = create_match(match_data).await?;
```

```rust Tauri Command
#[tauri::command]
pub fn create_match(
    state: State<'_, DbState>,
    match_data: MatchData,
) -> Result<Match, String>
```

</CodeGroup>

**Response:**
```json
{
  "id": 1,
  "show_id": 1,
  "match_name": "Main Event Championship Match",
  "match_type": "Singles",
  "match_stipulation": "Title Match",
  "scheduled_date": null,
  "match_order": 5,
  "winner_id": null,
  "is_title_match": true,
  "title_id": 1,
  "created_at": "2025-01-31T10:00:00",
  "updated_at": "2025-01-31T10:00:00"
}
```

### Get Matches for Show

<CodeGroup>

```rust Frontend (Leptos)
use crate::types::get_matches_for_show;

let matches = get_matches_for_show(show_id).await?;
```

```rust Tauri Command
#[tauri::command]
pub fn get_matches_for_show(
    state: State<'_, DbState>,
    show_id: i32,
) -> Result<Vec<Match>, String>
```

</CodeGroup>

**Parameters:**
- `show_id`: Integer ID of the show

## Match Participant Management

### Add Wrestler to Match

<CodeGroup>

```rust Frontend (Leptos)
use crate::types::add_wrestler_to_match;

let participant = add_wrestler_to_match(
    match_id,
    wrestler_id,
    Some(1), // team_number (for tag matches)
    Some(1)  // entrance_order
).await?;
```

```rust Tauri Command
#[tauri::command]
pub fn add_wrestler_to_match(
    state: State<'_, DbState>,
    match_id: i32,
    wrestler_id: i32,
    team_number: Option<i32>,
    entrance_order: Option<i32>,
) -> Result<MatchParticipant, String>
```

</CodeGroup>

**Parameters:**
- `match_id`: Integer ID of the match
- `wrestler_id`: Integer ID of the wrestler
- `team_number`: Optional team assignment (for tag team matches)
- `entrance_order`: Optional entrance order (1 = first to enter)

### Get Match Participants

<CodeGroup>

```rust Frontend (Leptos)
use crate::types::get_match_participants;

let participants = get_match_participants(match_id).await?;
```

```rust Tauri Command
#[tauri::command]
pub fn get_match_participants(
    state: State<'_, DbState>,
    match_id: i32,
) -> Result<Vec<MatchParticipantWithWrestler>, String>
```

</CodeGroup>

**Response:**
```json
[
  {
    "id": 1,
    "match_id": 1,
    "wrestler_id": 1,
    "wrestler_name": "John Cena",
    "team_number": 1,
    "entrance_order": 1
  },
  {
    "id": 2,
    "match_id": 1,
    "wrestler_id": 2,
    "wrestler_name": "Randy Orton",
    "team_number": 2,
    "entrance_order": 2
  }
]
```

## Match Results

### Set Match Winner

<CodeGroup>

```rust Frontend (Leptos)
use crate::types::set_match_winner;

let updated_match = set_match_winner(match_id, winner_id).await?;
```

```rust Tauri Command
#[tauri::command]
pub fn set_match_winner(
    state: State<'_, DbState>,
    match_id: i32,
    winner_id: i32,
) -> Result<Match, String>
```

</CodeGroup>

**Parameters:**
- `match_id`: Integer ID of the match
- `winner_id`: Integer ID of the winning wrestler

**Note:** The winner must be a participant in the match.

## Data Types

### Match

```rust
pub struct Match {
    pub id: i32,
    pub show_id: i32,
    pub match_name: Option<String>,
    pub match_type: String,
    pub match_stipulation: Option<String>,
    pub scheduled_date: Option<chrono::NaiveDate>,
    pub match_order: Option<i32>,
    pub winner_id: Option<i32>,
    pub is_title_match: bool,
    pub title_id: Option<i32>,
    pub created_at: Option<chrono::NaiveDateTime>,
    pub updated_at: Option<chrono::NaiveDateTime>,
}
```

### MatchData

```rust
pub struct MatchData {
    pub show_id: i32,
    pub match_name: Option<String>,
    pub match_type: String,
    pub match_stipulation: Option<String>,
    pub scheduled_date: Option<chrono::NaiveDate>,
    pub match_order: Option<i32>,
    pub is_title_match: bool,
    pub title_id: Option<i32>,
}
```

### MatchParticipant

```rust
pub struct MatchParticipant {
    pub id: i32,
    pub match_id: i32,
    pub wrestler_id: i32,
    pub team_number: Option<i32>,
    pub entrance_order: Option<i32>,
}
```

### MatchParticipantWithWrestler

```rust
pub struct MatchParticipantWithWrestler {
    pub id: i32,
    pub match_id: i32,
    pub wrestler_id: i32,
    pub wrestler_name: String,
    pub team_number: Option<i32>,
    pub entrance_order: Option<i32>,
}
```

## Match Types

Common match types include:
- **Singles**: One-on-one match
- **Tag Team**: Two-on-two team match
- **Triple Threat**: Three-way match
- **Fatal Four Way**: Four-way match
- **Battle Royal**: Multiple participants, last person standing wins
- **Ladder Match**: First to retrieve object suspended above ring
- **Cage Match**: Contested inside a steel cage
- **Hell in a Cell**: Inside the Hell in a Cell structure

## Match Stipulations

Common stipulations include:
- **Title Match**: Championship on the line
- **No Disqualification**: No rules disqualifications
- **Tables Match**: Must put opponent through table
- **Last Man Standing**: Must be unable to answer 10-count
- **Submission Match**: Can only win by submission
- **Iron Man Match**: Most falls in time limit wins

## Title Match Integration

When `is_title_match` is `true`:
- Must specify `title_id`
- Winner automatically becomes new champion
- Title holder history is updated
- Previous champion's reign ends

## Error Handling

All match operations return `Result<T, String>`:

- **Database connection errors**: "Failed to get database connection"
- **Match not found**: "Match with id {id} not found"
- **Invalid participant**: "Wrestler {id} is not a participant in match {match_id}"
- **Show not found**: "Show with id {id} not found"
- **Title conflicts**: "Title is already assigned to another show"
- **Duplicate participants**: "Wrestler {id} is already in this match"

## Usage Examples

### Creating a Championship Match

```rust
// 1. Create the match
let match_data = MatchData {
    show_id: 1,
    match_name: Some("WWE Championship Match".to_string()),
    match_type: "Singles".to_string(),
    match_stipulation: Some("Title Match".to_string()),
    match_order: Some(1),
    is_title_match: true,
    title_id: Some(1), // WWE Championship
    scheduled_date: None,
};

let match_obj = create_match(match_data).await?;

// 2. Add participants
add_wrestler_to_match(match_obj.id, 1, None, Some(1)).await?; // Champion
add_wrestler_to_match(match_obj.id, 2, None, Some(2)).await?; // Challenger

// 3. Set winner after match
set_match_winner(match_obj.id, 2).await?; // Challenger wins
```

### Creating a Tag Team Match

```rust
let match_data = MatchData {
    show_id: 1,
    match_name: Some("Tag Team Championship".to_string()),
    match_type: "Tag Team".to_string(),
    match_stipulation: Some("Title Match".to_string()),
    match_order: Some(3),
    is_title_match: true,
    title_id: Some(2), // Tag Team Championship
    scheduled_date: None,
};

let match_obj = create_match(match_data).await?;

// Team 1 (Champions)
add_wrestler_to_match(match_obj.id, 1, Some(1), Some(1)).await?;
add_wrestler_to_match(match_obj.id, 2, Some(1), Some(2)).await?;

// Team 2 (Challengers)  
add_wrestler_to_match(match_obj.id, 3, Some(2), Some(3)).await?;
add_wrestler_to_match(match_obj.id, 4, Some(2), Some(4)).await?;

// Team 2 wins
set_match_winner(match_obj.id, 3).await?; // Any member of winning team
```